<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ü§ñ Bot Game</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
    <!-- Welcome Modal -->
    <div id="welcome-modal" class="welcome-modal" style="display: none;">
        <div class="welcome-content">
            <div class="welcome-header">
                <h2>üéÆ Welcome to Bot Game!</h2>
                <button id="close-welcome" class="close-btn">&times;</button>
            </div>
            <div class="welcome-body">
                <p><strong>Welcome to the Bot Game portion of the BAPFT!</strong></p>
                <div class="welcome-instructions">
                    <p>Here, you will be tasked with solving robot puzzles. Solutions exceeding the par for a given level will receive no more than half credit. Please take screenshots of your solution with either the check or the star and your code, storing them in a document.</p>
                </div>
                <div class="welcome-actions">
                    <button id="start-playing" class="btn btn-primary">Begin Test</button>
                    <button id="skip-intro" class="btn btn-secondary">Close</button>
                </div>
            </div>
        </div>
    </div>

    <div class="container">
        <header>
            <h1>ü§ñ Bot Game</h1>
            <p>Write Python code to guide your bot to the finish line!</p>
            <div class="progress-summary">
                <span id="total-stars">‚≠ê 0</span>
                <span id="levels-completed">üìä 0/15 Levels</span>
            </div>
        </header>

        <div class="level-selector">
            <div class="level-info">
                <h2 id="level-title">
                    <span id="level-completion-icon"></span>
                    Level 1: Loading...
                </h2>
                <p id="level-description">Loading level...</p>
                <div class="level-meta">
                    <span id="level-difficulty" class="badge">Easy</span>
                    <span id="level-size" class="badge">5x5</span>
                    <span id="level-best" class="badge level-stats" style="display:none;">üèÜ Best: 0</span>
                </div>
            </div>
            <div class="level-controls">
                <button id="prev-level" class="btn btn-nav">‚óÄ Previous</button>
                <select id="level-select" class="level-dropdown"></select>
                <button id="next-level" class="btn btn-nav">Next ‚ñ∂</button>
            </div>
        </div>

        <div class="game-area">
            <div class="grid-container">
                <h3>Game Grid</h3>
                <div id="grid-display" class="grid-display">
                    Loading grid...
                </div>
                <div class="game-info">
                    <div id="bot-status">Bot Status: Ready</div>
                    <div id="command-count">Commands Used: 0</div>
                    <div id="max-commands">Max Commands: 3</div>
                </div>
            </div>

            <div class="code-area">
                <h3>Your Python Code</h3>
                <textarea id="code-input" placeholder="Write your bot code here...

Example:
while True:
    if bot.can_move():
        bot.move_forward()
    else:
        bot.turn_right()">while True:
    if bot.can_move():
        bot.move_forward()
    else:
        bot.turn_right()</textarea>
                
                <div class="controls">
                    <label for="delay-slider">Animation Speed:</label>
                    <input type="range" id="delay-slider" min="0" max="2" step="0.1" value="0.5">
                    <span id="delay-value">0.5s</span>
                </div>
                
                <div class="button-group">
                    <button id="run-code" class="btn btn-primary">üöÄ Run Code</button>
                    <button id="reset-grid" class="btn btn-secondary">üîÑ Reset</button>
                </div>
                
                <div class="output-area">
                    <h4>Output</h4>
                    <div id="output">Ready to execute code...</div>
                </div>
            </div>
        </div>

        <div class="instructions">
            <h3>How to Play</h3>
            <ul>
                <li><strong>bot.move_forward()</strong> - Move the bot forward in its current direction</li>
                <li><strong>bot.move_backward()</strong> - Move the bot backward from its current direction</li>
                <li><strong>bot.turn_left()</strong> - Turn the bot left (counterclockwise)</li>
                <li><strong>bot.turn_right()</strong> - Turn the bot right (clockwise)</li>
                <li><strong>bot.can_move()</strong> - Check if the bot can move forward (returns True/False)</li>
                <li><strong>bot.can_move_back()</strong> - Check if the bot can move backward (returns True/False)</li>

            </ul>
            <p><strong>Goal:</strong> Get your bot (ü§ñ) to reach the finish line (üü´) using as few commands as possible!</p>
            <p><strong>Legend:</strong> ‚¨ú Empty, ‚¨õ Wall, üüß Zappy wall, üü´ Finish line</p>
            <p><strong>Keys & Gates:</strong> üü° Yellow key, üü® Yellow gate, üî¥ Red key, üü• Red gate, üîµ Blue key, üü¶ Blue gate, üü¢ Green key, üü© Green gate, üü£ Purple key, üü™ Purple gate</p>
            <p><strong>Bot Directions:</strong> ‚¨ÜÔ∏è Up, ‚¨ÖÔ∏è Left, ‚¨áÔ∏è Down, ‚û°Ô∏è Right</p>
        </div>
    </div>

    <script>
        // Bot Game JavaScript
        let isLoading = false;
        let currentLevel = 1;
        let allLevels = [];
        let shouldInterrupt = false;  // Flag to interrupt execution

        // Load initial grid
        document.addEventListener('DOMContentLoaded', function() {
            loadLevels();
            setupDelaySlider();
            setupTabSupport();
            setupWelcomeModal();
        });

        function setupDelaySlider() {
            const slider = document.getElementById('delay-slider');
            const value = document.getElementById('delay-value');
            
            slider.addEventListener('input', function() {
                value.textContent = this.value + 's';
            });
        }

        function setupTabSupport() {
            const codeInput = document.getElementById('code-input');
            if (!codeInput) return;
            
            codeInput.addEventListener('keydown', function(e) {
                if (e.key === 'Tab') {
                    e.preventDefault();
                    
                    // Get cursor position
                    const start = this.selectionStart;
                    const end = this.selectionEnd;
                    
                    // Insert tab character (4 spaces)
                    const tab = '    ';
                    this.value = this.value.substring(0, start) + tab + this.value.substring(end);
                    
                    // Move cursor after the inserted tab
                    this.selectionStart = this.selectionEnd = start + tab.length;
                }
            });
        }

        function setupWelcomeModal() {
            // Check if user has seen welcome before
            const hasSeenWelcome = localStorage.getItem('botGameWelcomeSeen');
            
            if (!hasSeenWelcome) {
                // Show welcome modal after a short delay
                setTimeout(() => {
                    const modal = document.getElementById('welcome-modal');
                    if (modal) {
                        modal.style.display = 'flex';
                    }
                }, 500);
            }
            
            // Close button
            const closeBtn = document.getElementById('close-welcome');
            if (closeBtn) {
                closeBtn.addEventListener('click', closeWelcomeModal);
            }
            
            // Start playing button
            const startBtn = document.getElementById('start-playing');
            if (startBtn) {
                startBtn.addEventListener('click', () => {
                    closeWelcomeModal();
                    // Focus on code input
                    const codeInput = document.getElementById('code-input');
                    if (codeInput) {
                        codeInput.focus();
                    }
                });
            }
            
            // Skip intro button
            const skipBtn = document.getElementById('skip-intro');
            if (skipBtn) {
                skipBtn.addEventListener('click', closeWelcomeModal);
            }
            
            // Close on background click
            const modal = document.getElementById('welcome-modal');
            if (modal) {
                modal.addEventListener('click', function(e) {
                    if (e.target === modal) {
                        closeWelcomeModal();
                    }
                });
            }
            
            // Close on Escape key
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    const modal = document.getElementById('welcome-modal');
                    if (modal && modal.style.display === 'flex') {
                        closeWelcomeModal();
                    }
                }
            });
        }
        
        function closeWelcomeModal() {
            const modal = document.getElementById('welcome-modal');
            if (modal) {
                modal.style.display = 'none';
                // Mark as seen
                localStorage.setItem('botGameWelcomeSeen', 'true');
            }
        }

        async function loadLevels() {
            try {
                const response = await fetch('/levels');
                const data = await response.json();
                allLevels = data.levels;
                
                // Populate level dropdown with completion icons
                const dropdown = document.getElementById('level-select');
                dropdown.innerHTML = '';
                for (const level of allLevels) {
                    const option = document.createElement('option');
                    option.value = level.number;
                    option.textContent = `${level.icon} Level ${level.number}: ${level.name}`;
                    dropdown.appendChild(option);
                }
                
                // Update progress summary
                await updateProgressSummary();
                
                // Load the first level
                await loadGrid(1);
            } catch (error) {
                addOutput('Error loading levels: ' + error.message, 'error');
            }
        }

        async function loadGrid(levelNumber = null) {
            if (levelNumber !== null) {
                currentLevel = levelNumber;
            }
            
            try {
                const response = await fetch(`/grid?level=${currentLevel}`);
                const data = await response.json();
                
                if (data.error) {
                    addOutput('Error: ' + data.error, 'error');
                    return;
                }
                
                // Update grid display
                const gridDisplayElement = document.getElementById('grid-display');
                if (gridDisplayElement) {
                    gridDisplayElement.textContent = data.grid_state;
                }
                
                const maxCommandsElement = document.getElementById('max-commands');
                if (maxCommandsElement) {
                    maxCommandsElement.textContent = `Par: ${data.max_commands} commands`;
                }
                
                // Update level info
                const levelInfo = data.level_info;
                const levelTitleElement = document.getElementById('level-title');
                if (levelTitleElement) {
                    levelTitleElement.textContent = `Level ${levelInfo.number}: ${levelInfo.name}`;
                }
                
                const levelDescriptionElement = document.getElementById('level-description');
                if (levelDescriptionElement) {
                    levelDescriptionElement.textContent = levelInfo.description;
                }
                
                const levelDifficultyElement = document.getElementById('level-difficulty');
                if (levelDifficultyElement) {
                    levelDifficultyElement.textContent = levelInfo.difficulty;
                    levelDifficultyElement.className = `badge difficulty-${levelInfo.difficulty.toLowerCase()}`;
                }
                
                const levelSizeElement = document.getElementById('level-size');
                if (levelSizeElement) {
                    levelSizeElement.textContent = levelInfo.size;
                }
                
                // Update dropdown
                const levelSelectElement = document.getElementById('level-select');
                if (levelSelectElement) {
                    levelSelectElement.value = currentLevel;
                }
                
                // Update navigation buttons
                const prevLevelElement = document.getElementById('prev-level');
                if (prevLevelElement) {
                    prevLevelElement.disabled = currentLevel === 1;
                }
                
                const nextLevelElement = document.getElementById('next-level');
                if (nextLevelElement) {
                    nextLevelElement.disabled = currentLevel === allLevels.length;
                }
                
                // Update level progress display
                await updateLevelProgress(currentLevel);
                
            } catch (error) {
                addOutput('Error loading grid: ' + error.message, 'error');
            }
        }

        async function updateProgressSummary() {
            try {
                const response = await fetch('/progress/stats');
                const stats = await response.json();
                const totalStarsElement = document.getElementById('total-stars');
                const levelsCompletedElement = document.getElementById('levels-completed');
                
                if (totalStarsElement) {
                    totalStarsElement.textContent = `‚≠ê ${stats.total_stars}`;
                }
                if (levelsCompletedElement) {
                    levelsCompletedElement.textContent = `üìä ${stats.levels_completed}/${stats.total_levels} Levels`;
                }
            } catch (error) {
                console.error('Failed to update progress summary:', error);
            }
        }

        async function updateLevelProgress(levelNumber) {
            try {
                const response = await fetch(`/progress/${levelNumber}`);
                const data = await response.json();
                const progress = data.progress;
                const icon = data.icon;
                
                // Update completion icon
                const completionIcon = document.getElementById('level-completion-icon');
                if (completionIcon) {
                    completionIcon.textContent = icon;
                }
                
                // Update stats if level has been completed
                const levelBest = document.getElementById('level-best');
                
                if (progress.completed && progress.best_commands) {
                    if (levelBest) {
                        levelBest.style.display = 'inline-block';
                        levelBest.textContent = `üèÜ Best: ${progress.best_commands}`;
                    }
                } else {
                    if (levelBest) {
                        levelBest.style.display = 'none';
                    }
                }
            } catch (error) {
                console.error('Failed to update level progress:', error);
            }
        }

        async function playAnimation(frames, delay) {
            /**
             * Play frames sequentially with delay between each frame
             */
            for (let i = 0; i < frames.length; i++) {
                // Check for interruption
                if (shouldInterrupt) {
                    addOutput('‚èπÔ∏è Execution interrupted!', 'error');
                    throw new Error('Execution interrupted by user');
                }
                
                const frame = frames[i];
                
                // Update grid display
                const gridDisplayElement = document.getElementById('grid-display');
                if (gridDisplayElement) {
                    gridDisplayElement.textContent = frame.grid_state;
                }
                
                // Show current action
                if (i > 0) {  // Skip initial state
                    addOutput(`${i}. ${frame.action}`);
                }
                
                // Update bot status during animation
                const botStatusElement = document.getElementById('bot-status');
                if (botStatusElement) {
                    if (frame.win_state) {
                        botStatusElement.textContent = 'Bot Status: üèÜ VICTORY!';
                        botStatusElement.className = 'success';
                    } else if (!frame.alive) {
                        botStatusElement.textContent = 'Bot Status: üíÄ DEAD';
                        botStatusElement.className = 'error';
                    } else {
                        botStatusElement.textContent = 'Bot Status: üèÉ RUNNING';
                        botStatusElement.className = '';
                    }
                }
                
                // Wait for the delay before showing next frame (but always show the last frame)
                if (i < frames.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, delay * 1000));
                } else {
                    // Ensure final frame is visible for at least a moment
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
            }
            
            // Return the final frame for status updates
            return frames[frames.length - 1];
        }

        async function executeCode() {
            if (isLoading) return;
            
            isLoading = true;
            shouldInterrupt = false;  // Reset interrupt flag
            const runButton = document.getElementById('run-code');
            const codeInput = document.getElementById('code-input');
            const delaySlider = document.getElementById('delay-slider');
            
            if (!codeInput || !delaySlider) {
                addOutput('Error: Required UI elements not found', 'error');
                isLoading = false;
                return;
            }
            
            const code = codeInput.value;
            const delay = parseFloat(delaySlider.value);
            
            if (!code.trim()) {
                addOutput('Please enter some code to execute', 'error');
                isLoading = false;
                return;
            }

            if (runButton) {
                runButton.disabled = true;
                runButton.textContent = '‚è≥ Running...';
            }
            
            clearOutput();
            addOutput(`Executing code with ${delay}s delay between frames...`);

            try {
                const response = await fetch('/execute', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ 
                        code: code,
                        level: currentLevel
                    })
                });

                const result = await response.json();

                if (result.success || result.frames) {
                    let finalFrame = null;
                    
                    // Animate through all frames
                    if (result.frames && result.frames.length > 0) {
                        finalFrame = await playAnimation(result.frames, delay);
                    } else {
                        // Fallback: just show final state
                        document.getElementById('grid-display').textContent = result.grid_state;
                    }
                    
                    // Show final results
                    addOutput('‚îÄ'.repeat(40));
                    addOutput(result.message, result.success ? 'success' : 'error');
                    addOutput(`Total commands used: ${result.command_count}`);
                    
                    // Update final status based on result (takes precedence over frame data)
                    const commandCountElement = document.getElementById('command-count');
                    if (commandCountElement) {
                        commandCountElement.textContent = `Commands Used: ${result.command_count}`;
                    }
                    
                    // Ensure the final grid state is displayed
                    if (result.grid_state) {
                        const gridDisplayElement = document.getElementById('grid-display');
                        if (gridDisplayElement) {
                            gridDisplayElement.textContent = result.grid_state;
                        }
                    }
                    
                    // Record progress
                    const currentLevelInfo = allLevels.find(l => l.number === currentLevel);
                    const par = currentLevelInfo ? currentLevelInfo.par : 999;
                    
                    const progressResponse = await fetch('/progress/save', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            level_number: currentLevel,
                            commands_used: result.command_count,
                            par: par,
                            completed: result.win_state
                        })
                    });
                    const levelProgress = await progressResponse.json();
                    
                    // Update status - use result data which is authoritative
                    if (result.win_state) {
                        const botStatusElement = document.getElementById('bot-status');
                        if (botStatusElement) {
                            botStatusElement.textContent = 'Bot Status: üèÜ VICTORY!';
                            botStatusElement.className = 'success';
                        }
                        
                        // Show completion message
                        const progressData = levelProgress.progress || levelProgress;
                        const starMessage = progressData.has_star ? '‚≠ê Perfect! Completed at or under par!' : '‚úÖ Completed!';
                        addOutput(starMessage, 'success');
                        
                        // Update progress displays
                        await updateProgressSummary();
                        await updateLevelProgress(currentLevel);
                        
                        // Refresh dropdown to show updated icons
                        const levelsResponse = await fetch('/levels');
                        const levelsData = await levelsResponse.json();
                        allLevels = levelsData.levels;
                        
                        const dropdown = document.getElementById('level-select');
                        if (dropdown) {
                            const currentValue = dropdown.value;
                            dropdown.innerHTML = '';
                            for (const level of allLevels) {
                                const option = document.createElement('option');
                                option.value = level.number;
                                option.textContent = `${level.icon} Level ${level.number}: ${level.name}`;
                                dropdown.appendChild(option);
                            }
                            dropdown.value = currentValue;
                        }
                        
                    } else if (!result.alive) {
                        const botStatusElement = document.getElementById('bot-status');
                        if (botStatusElement) {
                            botStatusElement.textContent = 'Bot Status: üíÄ DEAD';
                            botStatusElement.className = 'error';
                        }
                        updateLevelProgress(currentLevel);
                    } else {
                        const botStatusElement = document.getElementById('bot-status');
                        if (botStatusElement) {
                            botStatusElement.textContent = 'Bot Status: ‚úÖ COMPLETED';
                            botStatusElement.className = '';
                        }
                        updateLevelProgress(currentLevel);
                    }
                } else {
                    addOutput('‚ùå ' + result.error, 'error');
                    const botStatusElement = document.getElementById('bot-status');
                    if (botStatusElement) {
                        botStatusElement.textContent = 'Bot Status: ‚ùå ERROR';
                        botStatusElement.className = 'error';
                    }
                }

            } catch (error) {
                if (error.message === 'Execution interrupted by user') {
                    // Interruption already logged in playAnimation
                    const botStatusElement = document.getElementById('bot-status');
                    if (botStatusElement) {
                        botStatusElement.textContent = 'Bot Status: ‚èπÔ∏è INTERRUPTED';
                        botStatusElement.className = 'error';
                    }
                } else {
                    addOutput('Network error: ' + error.message, 'error');
                    const botStatusElement = document.getElementById('bot-status');
                    if (botStatusElement) {
                        botStatusElement.textContent = 'Bot Status: ‚ùå CONNECTION ERROR';
                        botStatusElement.className = 'error';
                    }
                }
            }

            if (runButton) {
                runButton.disabled = false;
                runButton.textContent = 'üöÄ Run Code';
            }
            isLoading = false;
        }

        async function resetGrid() {
            // Set interrupt flag to stop any running execution
            shouldInterrupt = true;
            
            const botStatusElement = document.getElementById('bot-status');
            if (botStatusElement) {
                botStatusElement.textContent = 'Bot Status: Ready';
                botStatusElement.className = '';
            }
            
            const commandCountElement = document.getElementById('command-count');
            if (commandCountElement) {
                commandCountElement.textContent = 'Commands Used: 0';
                commandCountElement.className = '';
            }
            
            await loadGrid();
            clearOutput();
            addOutput('Grid reset to starting position');
        }

        function addOutput(message, type = 'normal') {
            const output = document.getElementById('output');
            if (!output) {
                console.warn('Output element not found');
                return;
            }
            
            const timestamp = new Date().toLocaleTimeString();
            const className = type === 'error' ? 'error' : type === 'success' ? 'success' : '';
            
            output.innerHTML += `<div class="${className}">[${timestamp}] ${message}</div>`;
            output.scrollTop = output.scrollHeight;
        }

        function clearOutput() {
            const output = document.getElementById('output');
            if (output) {
                output.innerHTML = '';
            }
        }

        // Event listeners with null checks
        const runCodeElement = document.getElementById('run-code');
        if (runCodeElement) {
            runCodeElement.addEventListener('click', executeCode);
        }
        
        const resetGridElement = document.getElementById('reset-grid');
        if (resetGridElement) {
            resetGridElement.addEventListener('click', resetGrid);
        }
        
        // Level navigation
        const prevLevelElement = document.getElementById('prev-level');
        if (prevLevelElement) {
            prevLevelElement.addEventListener('click', async function() {
                if (currentLevel > 1) {
                    await loadGrid(currentLevel - 1);
                    clearOutput();
                    addOutput(`Loaded Level ${currentLevel}`);
                }
            });
        }
        
        const nextLevelElement = document.getElementById('next-level');
        if (nextLevelElement) {
            nextLevelElement.addEventListener('click', async function() {
                if (currentLevel < allLevels.length) {
                    await loadGrid(currentLevel + 1);
                    clearOutput();
                    addOutput(`Loaded Level ${currentLevel}`);
                }
            });
        }
        
        const levelSelectElement = document.getElementById('level-select');
        if (levelSelectElement) {
            levelSelectElement.addEventListener('change', async function() {
                await loadGrid(parseInt(this.value));
                clearOutput();
                addOutput(`Loaded Level ${currentLevel}`);
            });
        }

        // Keyboard shortcut
        document.addEventListener('keydown', function(e) {
            if (e.ctrlKey && e.key === 'Enter') {
                e.preventDefault();
                executeCode();
            }
        });
    </script>
</body>
</html>

