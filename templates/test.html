<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üß™ Bot Game - Testing Environment</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <script src="https://unpkg.com/blockly@9.2.0/blockly.min.js"></script>
    <link href="https://unpkg.com/blockly@9.2.0/blockly.min.css" rel="stylesheet" />
    <style>
        .test-banner {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%);
            color: white;
            padding: 15px 20px;
            text-align: center;
            font-weight: bold;
            font-size: 1.1rem;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            position: sticky;
            top: 0;
            z-index: 100;
            border-bottom: 3px solid #ff4757;
        }
        .test-banner a {
            color: white;
            text-decoration: underline;
            margin-left: 10px;
        }
        .test-banner a:hover {
            color: #ffeaa7;
        }
    </style>
</head>
<body>
    <!-- Testing Environment Banner -->
    <div class="test-banner">
        üß™ TESTING ENVIRONMENT - This is a safe space for experimentation
        <a href="/">‚Üê Back to Main Game</a>
    </div>

    <div class="container">
        <header>
            <h1>üß™ Bot Game - Testing</h1>
            <p>Experiment with features here without affecting the main game!</p>
            <div class="progress-summary">
                <span id="total-stars">‚≠ê 0</span>
                <span id="levels-completed">üìä 0/15 Levels</span>
            </div>
        </header>

        <div class="level-selector">
            <div class="level-info">
                <h2 id="level-title">
                    <span id="level-completion-icon"></span>
                    Level 1: Loading...
                </h2>
                <p id="level-description">Loading level...</p>
                <div class="level-meta">
                    <span id="level-difficulty" class="badge">Easy</span>
                    <span id="level-size" class="badge">5x5</span>
                    <span id="level-best" class="badge level-stats" style="display:none;">üèÜ Best: 0</span>
                </div>
            </div>
            <div class="level-controls">
                <button id="prev-level" class="btn btn-nav">‚óÄ Previous</button>
                <select id="level-select" class="level-dropdown"></select>
                <button id="next-level" class="btn btn-nav">Next ‚ñ∂</button>
            </div>
        </div>

        <div class="game-area">
            <div class="grid-container">
                <h3>Game Grid</h3>
                <div id="grid-display" class="grid-display">
                    Loading grid...
                </div>
                <div class="game-info">
                    <div id="bot-status">Bot Status: Ready</div>
                    <div id="command-count">Commands Used: 0</div>
                    <div id="max-commands">Max Commands: 3</div>
                </div>
            </div>

            <div class="code-area">
                <h3>Your Python Code</h3>
                
                <!-- Tab Navigation -->
                <div class="editor-tabs">
                    <button class="tab-btn active" data-tab="text">üìù Text Editor</button>
                    <button class="tab-btn" data-tab="blocks">üß© Block Coding</button>
                </div>
                
                <!-- Text Editor Tab -->
                <div id="text-editor-tab" class="editor-tab-content active">
                    <textarea id="code-input" spellcheck="false" placeholder="Write your bot code here...

Example:
for k in range(10):
    if bot.can_move():
        bot.move_forward()
    else:
        bot.turn_right()"></textarea>
                </div>
                
                <!-- Block Coding Tab -->
                <div id="blocks-editor-tab" class="editor-tab-content">
                    <div id="blockly-workspace" style="height: 400px; width: 100%;"></div>
                </div>
                
                <div class="controls">
                    <label for="delay-slider">Animation Speed:</label>
                    <input type="range" id="delay-slider" min="0" max="1" step="0.025" value="0.5">
                    <span id="delay-value">0.5s</span>
                </div>
                
                <div class="button-group">
                    <button id="run-code" class="btn btn-primary">üöÄ Run Code</button>
                    <button id="reset-grid" class="btn btn-secondary">üîÑ Reset</button>
                </div>
                
                <div class="output-area">
                    <h4>Output</h4>
                    <div id="output">Ready to execute code...</div>
                </div>
            </div>
        </div>

        <div class="instructions">
            <h3>Testing Environment Notes</h3>
            <ul>
                <li><strong>This is a safe testing space</strong> - Changes here don't affect the main game</li>
                <li><strong>Progress is separate</strong> - Your test progress won't interfere with main game progress</li>
                <li><strong>Experiment freely</strong> - Try new features, test block coding, debug code</li>
                <li><strong>Same functionality</strong> - All game features work the same as the main game</li>
            </ul>
            <h3>How to Play</h3>
            <ul>
                <li><strong>bot.move_forward()</strong> - Move the bot forward in its current direction</li>
                <li><strong>bot.move_backward()</strong> - Move the bot backward from its current direction</li>
                <li><strong>bot.turn_left()</strong> - Turn the bot left (counterclockwise)</li>
                <li><strong>bot.turn_right()</strong> - Turn the bot right (clockwise)</li>
                <li><strong>bot.can_move()</strong> - Check if the bot can move forward (returns True/False)</li>
                <li><strong>bot.can_move_back()</strong> - Check if the bot can move backward (returns True/False)</li>
            </ul>
            <p><strong>Goal:</strong> Get your bot (ü§ñ) to reach the finish line (üü´) using as few commands as possible!</p>
            <p><strong>Legend:</strong> ‚¨ú Empty, ‚¨õ Wall, üüß Zappy wall, üü´ Finish line</p>
            <p><strong>Keys & Gates:</strong> üü° Yellow key, üü® Yellow gate, üî¥ Red key, üü• Red gate, üîµ Blue key, üü¶ Blue gate, üü¢ Green key, üü© Green gate, üü£ Purple key, üü™ Purple gate</p>
            <p><strong>Bot Directions:</strong> ‚¨ÜÔ∏è Up, ‚¨ÖÔ∏è Left, ‚¨áÔ∏è Down, ‚û°Ô∏è Right</p>
            <p><strong>Timeout:</strong>After 30 seconds, there will be a code timeout</p>
        </div>
    </div>

    <script>
        // Bot Game JavaScript - Same as main game
        let isLoading = false;
        let currentLevel = 1;
        let allLevels = [];
        let shouldInterrupt = false;
        let workspace = null;
        let currentEditorMode = 'text';

        // Load initial grid
        document.addEventListener('DOMContentLoaded', function() {
            loadLevels();
            setupDelaySlider();
            setupTabSupport();
            setupEditorTabs();
            initializeBlockly();
        });

        function setupDelaySlider() {
            const slider = document.getElementById('delay-slider');
            const value = document.getElementById('delay-value');
            
            slider.addEventListener('input', function() {
                value.textContent = this.value + 's';
            });
        }

        function setupTabSupport() {
            const codeInput = document.getElementById('code-input');
            if (!codeInput) return;
            
            codeInput.addEventListener('keydown', function(e) {
                if (e.key === 'Tab') {
                    e.preventDefault();
                    const start = this.selectionStart;
                    const end = this.selectionEnd;
                    const tab = '    ';
                    this.value = this.value.substring(0, start) + tab + this.value.substring(end);
                    this.selectionStart = this.selectionEnd = start + tab.length;
                }
                
                if ((e.ctrlKey || e.metaKey) && e.key === '/') {
                    e.preventDefault();
                    const start = this.selectionStart;
                    const end = this.selectionEnd;
                    const value = this.value;
                    let lineStart = value.lastIndexOf('\n', start - 1) + 1;
                    let lineEnd = value.indexOf('\n', end);
                    if (lineEnd === -1) lineEnd = value.length;
                    const selectedText = value.substring(lineStart, lineEnd);
                    const lines = selectedText.split('\n');
                    const shouldComment = !lines.every(line => line.trim().startsWith('#'));
                    const toggledLines = lines.map(line => {
                        if (shouldComment) {
                            return '# ' + line;
                        } else {
                            return line.replace(/^(\s*)#\s/, '$1');
                        }
                    });
                    const newText = toggledLines.join('\n');
                    this.value = value.substring(0, lineStart) + newText + value.substring(lineEnd);
                    this.selectionStart = lineStart;
                    this.selectionEnd = lineStart + newText.length;
                }
            });
        }

        function setupEditorTabs() {
            const tabButtons = document.querySelectorAll('.tab-btn');
            const tabContents = document.querySelectorAll('.editor-tab-content');
            
            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const targetTab = button.getAttribute('data-tab');
                    tabButtons.forEach(btn => btn.classList.remove('active'));
                    button.classList.add('active');
                    tabContents.forEach(content => content.classList.remove('active'));
                    if (targetTab === 'text') {
                        document.getElementById('text-editor-tab').classList.add('active');
                        currentEditorMode = 'text';
                    } else {
                        document.getElementById('blocks-editor-tab').classList.add('active');
                        currentEditorMode = 'blocks';
                        syncTextToBlocks();
                        if (workspace) {
                            setTimeout(() => {
                                Blockly.svgResize(workspace);
                            }, 100);
                        }
                    }
                });
            });
        }

        function initializeBlockly() {
            // Define start block - entry point for the program
            Blockly.Blocks['start'] = {
                init: function() {
                    this.appendDummyInput().appendField("‚ñ∂ START");
                    this.setNextStatement(true, null);
                    this.setColour(160); // Red/orange color for start
                    this.setTooltip("Start of your program - drag blocks here to begin");
                    this.setDeletable(false); // Can't delete the start block
                }
            };

            Blockly.Blocks['bot_move_forward'] = {
                init: function() {
                    this.appendDummyInput().appendField("move forward");
                    this.setPreviousStatement(true, null);
                    this.setNextStatement(true, null);
                    this.setColour(230);
                    this.setTooltip("Move the bot forward");
                }
            };

            Blockly.Blocks['bot_move_backward'] = {
                init: function() {
                    this.appendDummyInput().appendField("move backward");
                    this.setPreviousStatement(true, null);
                    this.setNextStatement(true, null);
                    this.setColour(230);
                    this.setTooltip("Move the bot backward");
                }
            };

            Blockly.Blocks['bot_turn_left'] = {
                init: function() {
                    this.appendDummyInput().appendField("turn left");
                    this.setPreviousStatement(true, null);
                    this.setNextStatement(true, null);
                    this.setColour(230);
                    this.setTooltip("Turn the bot left");
                }
            };

            Blockly.Blocks['bot_turn_right'] = {
                init: function() {
                    this.appendDummyInput().appendField("turn right");
                    this.setPreviousStatement(true, null);
                    this.setNextStatement(true, null);
                    this.setColour(230);
                    this.setTooltip("Turn the bot right");
                }
            };

            Blockly.Blocks['bot_can_move'] = {
                init: function() {
                    this.setOutput(true, 'Boolean');
                    this.appendDummyInput().appendField("can move");
                    this.setColour(120);
                    this.setTooltip("Check if bot can move forward");
                }
            };

            Blockly.Blocks['bot_can_move_back'] = {
                init: function() {
                    this.setOutput(true, 'Boolean');
                    this.appendDummyInput().appendField("can move back");
                    this.setColour(120);
                    this.setTooltip("Check if bot can move backward");
                }
            };

            // Define "change variable by" block
            Blockly.Blocks['variables_change'] = {
                init: function() {
                    this.appendValueInput('DELTA')
                        .setCheck('Number')
                        .appendField('change')
                        .appendField(new Blockly.FieldVariable(null), 'VAR')
                        .appendField('by');
                    this.setPreviousStatement(true, null);
                    this.setNextStatement(true, null);
                    this.setColour('#A65C81');
                    this.setTooltip('Change a variable by a number');
                }
            };

            window.BlocklyPython = {
                workspaceToCode: function(workspace) {
                    // First, collect all variables used in the workspace
                    const allBlocks = workspace.getAllBlocks(false);
                    const variablesUsed = new Set();
                    
                    allBlocks.forEach(block => {
                        if (block && (block.type === 'variables_get' || block.type === 'variables_set' || block.type === 'variables_change')) {
                            try {
                                // Get variable ID from the field
                                const varId = block.getFieldValue('VAR');
                                if (varId) {
                                    // Get the variable model from workspace using the ID
                                    const varModel = workspace.getVariableById(varId);
                                    if (varModel && varModel.name) {
                                        variablesUsed.add(varModel.name);
                                    } else {
                                        // Fallback: try to get from field text
                                        const varField = block.getField('VAR');
                                        if (varField && varField.getText) {
                                            const varName = varField.getText();
                                            if (varName) variablesUsed.add(varName);
                                        }
                                    }
                                }
                            } catch (e) {
                                // Skip if we can't get variable name
                                console.error('Error collecting variable:', e);
                            }
                        }
                    });
                    
                    // Initialize all variables to 0 at the start
                    let code = '';
                    if (variablesUsed.size > 0) {
                        const varNames = Array.from(variablesUsed).sort();
                        varNames.forEach(varName => {
                            code += `${varName} = 0\n`;
                        });
                    }
                    
                    // Look for start block first
                    let startBlock = null;
                    for (let i = 0; i < allBlocks.length; i++) {
                        if (allBlocks[i].type === 'start') {
                            startBlock = allBlocks[i];
                            break;
                        }
                    }
                    
                    if (startBlock) {
                        // Start from the start block and follow the chain
                        const nextBlock = startBlock.getNextBlock();
                        if (nextBlock) {
                            code += this.blockToCode(nextBlock, '', new Set());
                        }
                    } else {
                        // Fallback: use top blocks if no start block exists
                        const topBlocks = workspace.getTopBlocks(true);
                        const visited = new Set();
                        topBlocks.forEach(block => {
                            code += this.blockToCode(block, '', visited);
                        });
                    }
                    
                    return code;
                },
                
                blockToCode: function(block, indent, visited) {
                    if (!block) return '';
                    
                    // Prevent infinite recursion by tracking visited blocks
                    if (!visited) visited = new Set();
                    const blockId = block.id;
                    if (visited.has(blockId)) {
                        console.warn('Circular block reference detected:', block.type);
                        return '';
                    }
                    visited.add(blockId);
                    
                    let code = '';
                    const indentStr = indent || '';
                    const nextIndent = indent + '    ';
                    
                    switch(block.type) {
                        case 'start':
                            // Start block doesn't generate code, just passes through to next block
                            code = '';
                            break;
                        case 'bot_move_forward':
                            code = indentStr + 'bot.move_forward()\n';
                            break;
                        case 'bot_move_backward':
                            code = indentStr + 'bot.move_backward()\n';
                            break;
                        case 'bot_turn_left':
                            code = indentStr + 'bot.turn_left()\n';
                            break;
                        case 'bot_turn_right':
                            code = indentStr + 'bot.turn_right()\n';
                            break;
                        case 'bot_can_move':
                            return 'bot.can_move()';
                        case 'bot_can_move_back':
                            return 'bot.can_move_back()';
                        case 'controls_repeat_ext':
                            // Get the number of times to repeat
                            let times = this.valueToCode(block, 'TIMES', visited);
                            if (!times || times.trim() === '') {
                                times = '10'; // Default to 10 if not provided
                            } else {
                                times = times.trim(); // Clean up any whitespace
                            }
                            
                            // Get the loop body
                            let branch = this.statementToCode(block, 'DO', indentStr, visited);
                            if (!branch || !branch.trim()) {
                                branch = indentStr + '    pass\n';
                            }
                            
                            // Generate the for loop
                            code = indentStr + `for k in range(${times}):\n${branch}`;
                            
                            // Handle next block after the loop
                            const nextConn = block.nextConnection;
                            if (nextConn && nextConn.targetBlock()) {
                                code += this.blockToCode(nextConn.targetBlock(), indent, visited);
                            }
                            
                            visited.delete(blockId);
                            return code;
                        case 'controls_whileUntil':
                            const until = block.getFieldValue('MODE') === 'UNTIL';
                            // Get condition from BOOL input
                            let condition = this.valueToCode(block, 'BOOL', visited);
                            
                            // If condition is empty, check if input is connected
                            if (!condition || condition.trim() === '') {
                                const boolInput = block.getInput('BOOL');
                                if (boolInput && boolInput.connection && boolInput.connection.targetBlock()) {
                                    // Input is connected, try to generate condition manually
                                    const conditionBlock = boolInput.connection.targetBlock();
                                    condition = this.blockToCode(conditionBlock, '', visited);
                                    // Trim any whitespace
                                    if (condition) condition = condition.trim();
                                }
                                
                                // If still no condition, use False to prevent infinite loop
                                if (!condition || condition === '') {
                                    condition = 'False';
                                }
                            } else {
                                // Trim condition to remove any extra whitespace
                                condition = condition.trim();
                            }
                            
                            branch = this.statementToCode(block, 'DO', indentStr, visited);
                            if (!branch.trim()) branch = indentStr + '    pass\n';
                            
                            if (until) {
                                // For "repeat until", wrap condition in not()
                                code = indentStr + `while not (${condition}):\n${branch}`;
                            } else {
                                // For "repeat while", use condition directly
                                code = indentStr + `while ${condition}:\n${branch}`;
                            }
                            
                            // Handle next block after the while loop
                            const nextConnWhile = block.nextConnection;
                            if (nextConnWhile && nextConnWhile.targetBlock()) {
                                code += this.blockToCode(nextConnWhile.targetBlock(), indent, visited);
                            }
                            visited.delete(blockId);
                            return code;
                        case 'controls_if':
                            let ifCode = indentStr + 'if ' + (this.valueToCode(block, 'IF0', visited) || 'True') + ':\n';
                            let doCode = this.statementToCode(block, 'DO0', indentStr, visited);
                            if (!doCode.trim()) doCode = indentStr + '    pass\n';
                            ifCode += doCode;
                            if (block.elseifCount_ !== undefined) {
                                for (let i = 1; i <= block.elseifCount_; i++) {
                                    const elifCondition = this.valueToCode(block, 'IF' + i, visited) || 'True';
                                    ifCode += indentStr + 'elif ' + elifCondition + ':\n';
                                    doCode = this.statementToCode(block, 'DO' + i, indentStr, visited);
                                    if (!doCode.trim()) doCode = indentStr + '    pass\n';
                                    ifCode += doCode;
                                }
                            }
                            if (block.elseCount_ !== undefined && block.elseCount_ > 0) {
                                ifCode += indentStr + 'else:\n';
                                doCode = this.statementToCode(block, 'ELSE', indentStr, visited);
                                if (!doCode.trim()) doCode = indentStr + '    pass\n';
                                ifCode += doCode;
                            }
                            code = ifCode;
                            // Don't add next block to if - if statements should be self-contained
                            const nextConnIf = block.nextConnection;
                            if (nextConnIf && nextConnIf.targetBlock()) {
                                code += this.blockToCode(nextConnIf.targetBlock(), indent, visited);
                            }
                            visited.delete(blockId);
                            return code;
                        case 'logic_compare':
                            const left = this.valueToCode(block, 'A', visited) || 'True';
                            const operator = block.getFieldValue('OP');
                            const right = this.valueToCode(block, 'B', visited) || 'True';
                            const ops = {
                                'EQ': '==', 'NEQ': '!=', 'LT': '<', 'LTE': '<=', 'GT': '>', 'GTE': '>='
                            };
                            return `${left} ${ops[operator] || '=='} ${right}`;
                        case 'logic_operation':
                            const opA = this.valueToCode(block, 'A', visited) || 'True';
                            const logicOp = block.getFieldValue('OP');
                            const opB = this.valueToCode(block, 'B', visited) || 'True';
                            const operators = { 'AND': 'and', 'OR': 'or' };
                            return `${opA} ${operators[logicOp] || 'and'} ${opB}`;
                        case 'logic_negate':
                            const bool = this.valueToCode(block, 'BOOL', visited) || 'True';
                            return `not (${bool})`;
                        case 'math_number':
                            return block.getFieldValue('NUM') || '0';
                        case 'math_arithmetic':
                            const numA = this.valueToCode(block, 'A', visited) || '0';
                            const mathOp = block.getFieldValue('OP');
                            const numB = this.valueToCode(block, 'B', visited) || '0';
                            const mathOps = {
                                'ADD': '+', 'MINUS': '-', 'MULTIPLY': '*', 'DIVIDE': '/', 'POWER': '**'
                            };
                            return `${numA} ${mathOps[mathOp] || '+'} ${numB}`;
                        case 'variables_get':
                            // Get variable value - use workspace to get variable model by ID
                            try {
                                const varId = block.getFieldValue('VAR');
                                if (varId) {
                                    // Get the workspace from the block
                                    const workspace = block.workspace;
                                    if (workspace) {
                                        const varModel = workspace.getVariableById(varId);
                                        if (varModel && varModel.name) {
                                            return varModel.name;
                                        }
                                    }
                                }
                                // Fallback: try to get from field
                                const varField = block.getField('VAR');
                                if (varField && varField.getText) {
                                    return varField.getText();
                                }
                                // Last resort fallback
                                return varId || 'var';
                            } catch (e) {
                                console.error('Error getting variable name:', e);
                                return 'var';
                            }
                        case 'variables_set':
                            // Set variable value - use workspace to get variable model by ID
                            try {
                                const varId = block.getFieldValue('VAR');
                                let varNameSet = 'var';
                                if (varId) {
                                    const workspace = block.workspace;
                                    if (workspace) {
                                        const varModelSet = workspace.getVariableById(varId);
                                        if (varModelSet && varModelSet.name) {
                                            varNameSet = varModelSet.name;
                                        } else {
                                            // Fallback: try to get from field
                                            const varField = block.getField('VAR');
                                            if (varField && varField.getText) {
                                                varNameSet = varField.getText();
                                            }
                                        }
                                    } else {
                                        // Fallback: try to get from field
                                        const varField = block.getField('VAR');
                                        if (varField && varField.getText) {
                                            varNameSet = varField.getText();
                                        }
                                    }
                                }
                                const varValue = this.valueToCode(block, 'VALUE', visited) || '0';
                                code = indentStr + `${varNameSet} = ${varValue}\n`;
                                // Handle next block in chain
                                const nextConnVar = block.nextConnection;
                                if (nextConnVar && nextConnVar.targetBlock()) {
                                    code += this.blockToCode(nextConnVar.targetBlock(), indent, visited);
                                }
                                visited.delete(blockId);
                                return code;
                            } catch (e) {
                                console.error('Error setting variable:', e);
                                // Even on error, handle next block to continue execution
                                code = indentStr + 'var = 0\n';
                                const nextConnVar = block.nextConnection;
                                if (nextConnVar && nextConnVar.targetBlock()) {
                                    code += this.blockToCode(nextConnVar.targetBlock(), indent, visited);
                                }
                                visited.delete(blockId);
                                return code;
                            }
                        case 'variables_change':
                            // Change variable by a value - use workspace to get variable model by ID
                            try {
                                const varId = block.getFieldValue('VAR');
                                let varNameChange = 'var';
                                if (varId) {
                                    const workspace = block.workspace;
                                    if (workspace) {
                                        const varModelChange = workspace.getVariableById(varId);
                                        if (varModelChange && varModelChange.name) {
                                            varNameChange = varModelChange.name;
                                        } else {
                                            // Fallback: try to get from field
                                            const varField = block.getField('VAR');
                                            if (varField && varField.getText) {
                                                varNameChange = varField.getText();
                                            }
                                        }
                                    } else {
                                        // Fallback: try to get from field
                                        const varField = block.getField('VAR');
                                        if (varField && varField.getText) {
                                            varNameChange = varField.getText();
                                        }
                                    }
                                }
                                const delta = this.valueToCode(block, 'DELTA', visited) || '1';
                                code = indentStr + `${varNameChange} = ${varNameChange} + ${delta}\n`;
                                // Handle next block in chain
                                const nextConnChange = block.nextConnection;
                                if (nextConnChange && nextConnChange.targetBlock()) {
                                    code += this.blockToCode(nextConnChange.targetBlock(), indent, visited);
                                }
                                visited.delete(blockId);
                                return code;
                            } catch (e) {
                                console.error('Error changing variable:', e);
                                // Even on error, handle next block to continue execution
                                code = indentStr + 'var = var + 1\n';
                                const nextConnChange = block.nextConnection;
                                if (nextConnChange && nextConnChange.targetBlock()) {
                                    code += this.blockToCode(nextConnChange.targetBlock(), indent, visited);
                                }
                                visited.delete(blockId);
                                return code;
                            }
                        default:
                            const nextConnection = block.nextConnection;
                            if (nextConnection && nextConnection.targetBlock()) {
                                code = this.blockToCode(nextConnection.targetBlock(), indent, visited);
                            } else {
                                code = '';
                            }
                            break;
                    }
                    
                    const nextConn = block.nextConnection;
                    if (nextConn && nextConn.targetBlock()) {
                        code += this.blockToCode(nextConn.targetBlock(), indent, visited);
                    }
                    
                    visited.delete(blockId);
                    return code;
                },
                
                valueToCode: function(block, name, visited) {
                    const input = block.getInput(name);
                    if (!input || !input.connection) return null;
                    const targetBlock = input.connection.targetBlock();
                    if (!targetBlock) return null;
                    if (!visited) visited = new Set();
                    // For value blocks, we need to get just the value, not a statement
                    // Most value blocks return directly from their case statement
                    const code = this.blockToCode(targetBlock, '', visited);
                    // Remove any trailing newlines or whitespace, but preserve the value
                    if (!code) return null;
                    const trimmed = code.trim();
                    // If trimming results in empty string, return null
                    return trimmed === '' ? null : trimmed;
                },
                
                statementToCode: function(block, name, indent, visited) {
                    const input = block.getInput(name);
                    if (!input || !input.connection) {
                        return (indent || '') + '    pass\n';
                    }
                    const targetBlock = input.connection.targetBlock();
                    if (!targetBlock) {
                        return (indent || '') + '    pass\n';
                    }
                    if (!visited) visited = new Set();
                    let code = '';
                    let currentBlock = targetBlock;
                    let iterationCount = 0;
                    const maxIterations = 1000; // Safety limit to prevent infinite loops
                    const processedInChain = new Set(); // Track blocks in this specific chain
                    
                    while (currentBlock && iterationCount < maxIterations) {
                        // Check for circular reference in this specific chain
                        if (processedInChain.has(currentBlock.id)) {
                            console.warn('Circular reference detected in statement chain:', currentBlock.type);
                            break;
                        }
                        processedInChain.add(currentBlock.id);
                        
                        code += this.blockToCode(currentBlock, indent ? indent + '    ' : '    ', visited);
                        const nextConnection = currentBlock.nextConnection;
                        if (nextConnection && nextConnection.targetBlock()) {
                            currentBlock = nextConnection.targetBlock();
                            iterationCount++;
                        } else {
                            break;
                        }
                    }
                    
                    if (iterationCount >= maxIterations) {
                        console.error('Statement chain too long - stopping to prevent infinite loop');
                    }
                    
                    return code || ((indent || '') + '    pass\n');
                }
            };

            workspace = Blockly.inject('blockly-workspace', {
                toolbox: {
                    kind: 'categoryToolbox',
                    contents: [
                        {
                            kind: 'category',
                            name: 'Bot Actions',
                            colour: '#5C81A6',
                            contents: [
                                { kind: 'block', type: 'bot_move_forward' },
                                { kind: 'block', type: 'bot_move_backward' },
                                { kind: 'block', type: 'bot_turn_left' },
                                { kind: 'block', type: 'bot_turn_right' }
                            ]
                        },
                        {
                            kind: 'category',
                            name: 'Bot Checks',
                            colour: '#5BA55B',
                            contents: [
                                { kind: 'block', type: 'bot_can_move' },
                                { kind: 'block', type: 'bot_can_move_back' }
                            ]
                        },
                        {
                            kind: 'category',
                            name: 'Loops',
                            colour: '#5C81A6',
                            contents: [
                                { kind: 'block', type: 'controls_repeat_ext' },
                                { kind: 'block', type: 'controls_whileUntil' }
                            ]
                        },
                        {
                            kind: 'category',
                            name: 'Conditionals',
                            colour: '#5C81A6',
                            contents: [
                                { kind: 'block', type: 'controls_if' }
                            ]
                        },
                        {
                            kind: 'category',
                            name: 'Logic',
                            colour: '#5C81A6',
                            contents: [
                                { kind: 'block', type: 'logic_compare' },
                                { kind: 'block', type: 'logic_operation' },
                                { kind: 'block', type: 'logic_negate' }
                            ]
                        },
                        {
                            kind: 'category',
                            name: 'Math',
                            colour: '#5C81A6',
                            contents: [
                                { kind: 'block', type: 'math_number' },
                                { kind: 'block', type: 'math_arithmetic' }
                            ]
                        },
                        {
                            kind: 'category',
                            name: 'Variables',
                            colour: '#A65C81',
                            custom: 'VARIABLE',
                            contents: [
                                { kind: 'block', type: 'variables_change' }
                            ]
                        }
                    ]
                },
                grid: { spacing: 20, length: 3, colour: '#ccc', snap: true },
                zoom: { controls: true, wheel: true, startScale: 1.0, maxScale: 3, minScale: 0.3, scaleSpeed: 1.2 },
                trashcan: true
            });

            // Prevent users from creating additional start blocks
            let processingStartBlock = false; // Flag to prevent infinite loops
            workspace.addChangeListener(function(event) {
                try {
                    // Only process block creation events, and avoid processing if already handling one
                    if (!processingStartBlock && event.type === Blockly.Events.BLOCK_CREATE && event.blockId) {
                        const block = workspace.getBlockById(event.blockId);
                        if (block && block.type === 'start') {
                            processingStartBlock = true;
                            
                            // Count existing start blocks
                            const allBlocks = workspace.getAllBlocks(false);
                            let startBlockCount = 0;
                            allBlocks.forEach(b => {
                                if (b && b.type === 'start') {
                                    startBlockCount++;
                                }
                            });
                            
                            // If more than one start block exists, remove the newly created one
                            if (startBlockCount > 1) {
                                setTimeout(() => {
                                    try {
                                        if (block && !block.isDisposed()) {
                                            block.dispose();
                                        }
                                    } catch (e) {
                                        console.error('Error disposing start block:', e);
                                    } finally {
                                        processingStartBlock = false;
                                    }
                                }, 10);
                            } else {
                                processingStartBlock = false;
                            }
                        }
                    }
                } catch (e) {
                    console.error('Error in workspace change listener:', e);
                    processingStartBlock = false;
                }
            });

            // Add a start block to the workspace automatically if one doesn't exist
            // Only one start block is allowed
            setTimeout(() => {
                if (workspace) {
                    const allBlocks = workspace.getAllBlocks(false);
                    let startBlocks = [];
                    for (let i = 0; i < allBlocks.length; i++) {
                        if (allBlocks[i].type === 'start') {
                            startBlocks.push(allBlocks[i]);
                        }
                    }
                    
                    // Remove any extra start blocks (keep only the first one)
                    if (startBlocks.length > 1) {
                        for (let i = 1; i < startBlocks.length; i++) {
                            startBlocks[i].dispose();
                        }
                    }
                    
                    // Create start block if none exists
                    if (startBlocks.length === 0) {
                        const startBlock = workspace.newBlock('start');
                        startBlock.moveBy(20, 20);
                        startBlock.initSvg();
                        startBlock.render();
                    }
                    Blockly.svgResize(workspace);
                }
            }, 150);

            window.addEventListener('resize', function() {
                if (workspace && currentEditorMode === 'blocks') {
                    Blockly.svgResize(workspace);
                }
            });
        }

        function getCodeFromBlocks() {
            // Generate code from blocks without updating the text editor
            if (workspace && currentEditorMode === 'blocks') {
                return BlocklyPython.workspaceToCode(workspace);
            }
            return null;
        }


        function syncTextToBlocks() {
            // Don't sync text to blocks - keep them independent
            // When switching to blocks tab, blocks remain as they are
        }

        async function loadLevels() {
            try {
                const response = await fetch('/levels');
                const data = await response.json();
                allLevels = data.levels;
                const dropdown = document.getElementById('level-select');
                dropdown.innerHTML = '';
                for (const level of allLevels) {
                    const option = document.createElement('option');
                    option.value = level.number;
                    option.textContent = `${level.icon} Level ${level.number}: ${level.name}`;
                    dropdown.appendChild(option);
                }
                await updateProgressSummary();
                await loadGrid(1);
            } catch (error) {
                addOutput('Error loading levels: ' + error.message, 'error');
            }
        }

        async function loadGrid(levelNumber = null) {
            if (levelNumber !== null) {
                currentLevel = levelNumber;
            }
            try {
                const response = await fetch(`/grid?level=${currentLevel}`);
                const data = await response.json();
                if (data.error) {
                    addOutput('Error: ' + data.error, 'error');
                    return;
                }
                const gridDisplayElement = document.getElementById('grid-display');
                if (gridDisplayElement) {
                    gridDisplayElement.textContent = data.grid_state;
                }
                const maxCommandsElement = document.getElementById('max-commands');
                if (maxCommandsElement) {
                    maxCommandsElement.textContent = `Par: ${data.max_commands} commands`;
                }
                const levelInfo = data.level_info;
                const levelTitleElement = document.getElementById('level-title');
                if (levelTitleElement) {
                    levelTitleElement.textContent = `Level ${levelInfo.number}: ${levelInfo.name}`;
                }
                const levelDescriptionElement = document.getElementById('level-description');
                if (levelDescriptionElement) {
                    levelDescriptionElement.textContent = levelInfo.description;
                }
                const levelDifficultyElement = document.getElementById('level-difficulty');
                if (levelDifficultyElement) {
                    levelDifficultyElement.textContent = levelInfo.difficulty;
                    levelDifficultyElement.className = `badge difficulty-${levelInfo.difficulty.toLowerCase()}`;
                }
                const levelSizeElement = document.getElementById('level-size');
                if (levelSizeElement) {
                    levelSizeElement.textContent = levelInfo.size;
                }
                const levelSelectElement = document.getElementById('level-select');
                if (levelSelectElement) {
                    levelSelectElement.value = currentLevel;
                }
                const prevLevelElement = document.getElementById('prev-level');
                if (prevLevelElement) {
                    prevLevelElement.disabled = currentLevel === 1;
                }
                const nextLevelElement = document.getElementById('next-level');
                if (nextLevelElement) {
                    nextLevelElement.disabled = currentLevel === allLevels.length;
                }
                await updateLevelProgress(currentLevel);
            } catch (error) {
                addOutput('Error loading grid: ' + error.message, 'error');
            }
        }

        async function updateProgressSummary() {
            try {
                const response = await fetch('/progress/stats');
                const stats = await response.json();
                const totalStarsElement = document.getElementById('total-stars');
                const levelsCompletedElement = document.getElementById('levels-completed');
                if (totalStarsElement) {
                    totalStarsElement.textContent = `‚≠ê ${stats.total_stars}`;
                }
                if (levelsCompletedElement) {
                    levelsCompletedElement.textContent = `üìä ${stats.levels_completed}/${stats.total_levels} Levels`;
                }
            } catch (error) {
                console.error('Failed to update progress summary:', error);
            }
        }

        async function updateLevelProgress(levelNumber) {
            try {
                const response = await fetch(`/progress/${levelNumber}`);
                const data = await response.json();
                const progress = data.progress;
                const icon = data.icon;
                const completionIcon = document.getElementById('level-completion-icon');
                if (completionIcon) {
                    completionIcon.textContent = icon;
                }
                const levelBest = document.getElementById('level-best');
                if (progress.completed && progress.best_commands) {
                    if (levelBest) {
                        levelBest.style.display = 'inline-block';
                        levelBest.textContent = `üèÜ Best: ${progress.best_commands}`;
                    }
                } else {
                    if (levelBest) {
                        levelBest.style.display = 'none';
                    }
                }
            } catch (error) {
                console.error('Failed to update level progress:', error);
            }
        }

        async function playAnimation(frames, delay) {
            for (let i = 0; i < frames.length; i++) {
                if (shouldInterrupt) {
                    addOutput('‚èπÔ∏è Execution interrupted!', 'error');
                    throw new Error('Execution interrupted by user');
                }
                const frame = frames[i];
                const gridDisplayElement = document.getElementById('grid-display');
                if (gridDisplayElement) {
                    gridDisplayElement.textContent = frame.grid_state;
                }
                if (i > 0) {
                    addOutput(`${i}. ${frame.action}`);
                }
                const botStatusElement = document.getElementById('bot-status');
                if (botStatusElement) {
                    if (frame.win_state) {
                        botStatusElement.textContent = 'Bot Status: üèÜ VICTORY!';
                        botStatusElement.className = 'success';
                    } else if (!frame.alive) {
                        botStatusElement.textContent = 'Bot Status: üíÄ DEAD';
                        botStatusElement.className = 'error';
                    } else {
                        botStatusElement.textContent = 'Bot Status: üèÉ RUNNING';
                        botStatusElement.className = '';
                    }
                }
                if (i < frames.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, delay * 1000));
                } else {
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
            }
            return frames[frames.length - 1];
        }

        async function executeCode() {
            if (isLoading) return;
            isLoading = true;
            shouldInterrupt = false;
            const runButton = document.getElementById('run-code');
            const codeInput = document.getElementById('code-input');
            const delaySlider = document.getElementById('delay-slider');
            if (!codeInput || !delaySlider) {
                addOutput('Error: Required UI elements not found', 'error');
                isLoading = false;
                return;
            }
            let code;
            if (currentEditorMode === 'blocks') {
                // Generate code from blocks internally without updating text editor
                code = getCodeFromBlocks();
                if (!code) {
                    addOutput('No code generated from blocks', 'error');
                    isLoading = false;
                    if (runButton) {
                        runButton.disabled = false;
                        runButton.textContent = 'üöÄ Run Code';
                    }
                    return;
                }
            } else {
                // Get code from text editor
                code = codeInput.value;
            }
            const delay = parseFloat(delaySlider.value);
            if (!code.trim()) {
                addOutput('Please enter some code to execute', 'error');
                isLoading = false;
                return;
            }
            if (runButton) {
                runButton.disabled = true;
                runButton.textContent = '‚è≥ Running...';
            }
            clearOutput();
            try {
                await loadGrid(currentLevel);
                addOutput('‚ú® Grid refreshed - all keys and gates restored');
                addOutput(`Executing code with ${delay}s delay between frames...`);
            } catch (error) {
                addOutput('Error refreshing grid: ' + error.message, 'error');
                isLoading = false;
                if (runButton) {
                    runButton.disabled = false;
                    runButton.textContent = 'üöÄ Run Code';
                }
                return;
            }
            try {
                const response = await fetch('/execute', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        code: code, 
                        level: currentLevel
                    })
                });
                const result = await response.json();
                if (result.success || result.frames) {
                    let finalFrame = null;
                    if (result.frames && result.frames.length > 0) {
                        finalFrame = await playAnimation(result.frames, delay);
                    } else {
                        document.getElementById('grid-display').textContent = result.grid_state;
                    }
                    addOutput('‚îÄ'.repeat(40));
                    addOutput(result.message, result.success ? 'success' : 'error');
                    addOutput(`Total commands used: ${result.command_count}`);
                    const commandCountElement = document.getElementById('command-count');
                    if (commandCountElement) {
                        commandCountElement.textContent = `Commands Used: ${result.command_count}`;
                    }
                    if (result.grid_state) {
                        const gridDisplayElement = document.getElementById('grid-display');
                        if (gridDisplayElement) {
                            gridDisplayElement.textContent = result.grid_state;
                        }
                    }
                    const currentLevelInfo = allLevels.find(l => l.number === currentLevel);
                    const par = currentLevelInfo ? currentLevelInfo.par : 999;
                    
                    const progressResponse = await fetch('/progress/save', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            level_number: currentLevel,
                            commands_used: result.command_count,
                            par: par,
                            completed: result.win_state
                        })
                    });
                    const levelProgress = await progressResponse.json();
                    if (result.win_state) {
                        const botStatusElement = document.getElementById('bot-status');
                        if (botStatusElement) {
                            botStatusElement.textContent = 'Bot Status: üèÜ VICTORY!';
                            botStatusElement.className = 'success';
                        }
                        const progressData = levelProgress.progress || levelProgress;
                        const starMessage = progressData.has_star ? '‚≠ê Perfect! Completed at or under par!' : '‚úÖ Completed!';
                        addOutput(starMessage, 'success');
                        await updateProgressSummary();
                        await updateLevelProgress(currentLevel);
                        const levelsResponse = await fetch('/levels');
                        const levelsData = await levelsResponse.json();
                        allLevels = levelsData.levels;
                        const dropdown = document.getElementById('level-select');
                        if (dropdown) {
                            const currentValue = dropdown.value;
                            dropdown.innerHTML = '';
                            for (const level of allLevels) {
                                const option = document.createElement('option');
                                option.value = level.number;
                                option.textContent = `${level.icon} Level ${level.number}: ${level.name}`;
                                dropdown.appendChild(option);
                            }
                            dropdown.value = currentValue;
                        }
                    } else if (!result.alive) {
                        const botStatusElement = document.getElementById('bot-status');
                        if (botStatusElement) {
                            botStatusElement.textContent = 'Bot Status: üíÄ DEAD';
                            botStatusElement.className = 'error';
                        }
                        updateLevelProgress(currentLevel);
                    } else {
                        const botStatusElement = document.getElementById('bot-status');
                        if (botStatusElement) {
                            botStatusElement.textContent = 'Bot Status: ‚úÖ COMPLETED';
                            botStatusElement.className = '';
                        }
                        updateLevelProgress(currentLevel);
                    }
                } else {
                    addOutput('‚ùå ' + result.error, 'error');
                    const botStatusElement = document.getElementById('bot-status');
                    if (botStatusElement) {
                        botStatusElement.textContent = 'Bot Status: ‚ùå ERROR';
                        botStatusElement.className = 'error';
                    }
                }
            } catch (error) {
                if (error.message === 'Execution interrupted by user') {
                    const botStatusElement = document.getElementById('bot-status');
                    if (botStatusElement) {
                        botStatusElement.textContent = 'Bot Status: ‚èπÔ∏è INTERRUPTED';
                        botStatusElement.className = 'error';
                    }
                } else {
                    addOutput('Network error: ' + error.message, 'error');
                    const botStatusElement = document.getElementById('bot-status');
                    if (botStatusElement) {
                        botStatusElement.textContent = 'Bot Status: ‚ùå CONNECTION ERROR';
                        botStatusElement.className = 'error';
                    }
                }
            }
            if (runButton) {
                runButton.disabled = false;
                runButton.textContent = 'üöÄ Run Code';
            }
            isLoading = false;
        }

        async function resetGrid() {
            shouldInterrupt = true;
            const botStatusElement = document.getElementById('bot-status');
            if (botStatusElement) {
                botStatusElement.textContent = 'Bot Status: Ready';
                botStatusElement.className = '';
            }
            const commandCountElement = document.getElementById('command-count');
            if (commandCountElement) {
                commandCountElement.textContent = 'Commands Used: 0';
                commandCountElement.className = '';
            }
            clearOutput();
            addOutput('üîÑ Resetting grid...');
            addOutput('‚ú® Restoring all keys and gates to original positions');
            await loadGrid();
            addOutput('‚úÖ Grid reset complete - ready for new attempt');
        }

        function addOutput(message, type = 'normal') {
            const output = document.getElementById('output');
            if (!output) {
                console.warn('Output element not found');
                return;
            }
            const timestamp = new Date().toLocaleTimeString();
            const className = type === 'error' ? 'error' : type === 'success' ? 'success' : '';
            const div = document.createElement('div');
            div.className = className;
            div.textContent = `[${timestamp}] ${message}`;
            output.appendChild(div);
            output.scrollTop = output.scrollHeight;
        }

        function clearOutput() {
            const output = document.getElementById('output');
            if (output) {
                output.innerHTML = '';
            }
        }

        const runCodeElement = document.getElementById('run-code');
        if (runCodeElement) {
            runCodeElement.addEventListener('click', executeCode);
        }
        
        const resetGridElement = document.getElementById('reset-grid');
        if (resetGridElement) {
            resetGridElement.addEventListener('click', resetGrid);
        }
        
        const prevLevelElement = document.getElementById('prev-level');
        if (prevLevelElement) {
            prevLevelElement.addEventListener('click', async function() {
                if (currentLevel > 1) {
                    await loadGrid(currentLevel - 1);
                    clearOutput();
                    addOutput(`Loaded Level ${currentLevel}`);
                }
            });
        }
        
        const nextLevelElement = document.getElementById('next-level');
        if (nextLevelElement) {
            nextLevelElement.addEventListener('click', async function() {
                if (currentLevel < allLevels.length) {
                    await loadGrid(currentLevel + 1);
                    clearOutput();
                    addOutput(`Loaded Level ${currentLevel}`);
                }
            });
        }
        
        const levelSelectElement = document.getElementById('level-select');
        if (levelSelectElement) {
            levelSelectElement.addEventListener('change', async function() {
                await loadGrid(parseInt(this.value));
                clearOutput();
                addOutput(`Loaded Level ${currentLevel}`);
            });
        }

        document.addEventListener('keydown', function(e) {
            if (e.ctrlKey && e.key === 'Enter') {
                e.preventDefault();
                executeCode();
            }
        });
    </script>
</body>
</html>

